
CONTAINERD_NEEDS_RESTART=0
CONTAINERD_DID_MIGRATE_FROM_DOCKER=0

function containerd_pre_init() {
    local src="$DIR/addons/containerd/$CONTAINERD_VERSION"

    # Explicitly configure kubelet to use containerd instead of detecting dockershim socket
    if [ -d "$DIR/kustomize/kubeadm/init-patches" ]; then
        cp "$src/kubeadm-init-config-v1beta2.yaml" "$DIR/kustomize/kubeadm/init-patches/containerd-kubeadm-init-config-v1beta2.yml"
    fi
}

function containerd_join() {
    local src="$DIR/addons/containerd/$CONTAINERD_VERSION"

    # Explicitly configure kubelet to use containerd instead of detecting dockershim socket
    if [ -d "$DIR/kustomize/kubeadm/join-patches" ]; then
        cp "$src/kubeadm-join-config-v1beta2.yaml" "$DIR/kustomize/kubeadm/join-patches/containerd-kubeadm-join-config-v1beta2.yml"
    fi
}

function containerd_install() {
    local src="$DIR/addons/containerd/$CONTAINERD_VERSION"

    if ! containerd_xfs_ftype_enabled; then
        bail "The filesystem mounted at /var/lib/containerd does not have ftype enabled"
    fi

    containerd_migrate_from_docker

    install_host_packages "$src" containerd.io

    case "$LSB_DIST" in
        centos|rhel|amzn|ol)
            yum_install_host_archives "$src" libzstd
            ;;
    esac

    chmod +x ${DIR}/addons/containerd/${CONTAINERD_VERSION}/assets/runc
    # If the runc binary is executing the cp command will fail with "text file busy" error.
    # Containerd uses runc in detached mode so any runc processes should be short-lived and exit
    # as soon as the container starts
    try_1m_stderr cp ${DIR}/addons/containerd/${CONTAINERD_VERSION}/assets/runc $(which runc)

    containerd_configure

    systemctl enable containerd

    containerd_configure_ctl "$src"

    # NOTE: this will not remove the proxy
    if [ -n "$PROXY_ADDRESS" ]; then
        containerd_configure_proxy
    fi

    if commandExists ${K8S_DISTRO}_registry_containerd_configure && [ -n "$DOCKER_REGISTRY_IP" ]; then
        ${K8S_DISTRO}_registry_containerd_configure "$DOCKER_REGISTRY_IP"
        CONTAINERD_NEEDS_RESTART=1
    fi

    if [ "$CONTAINERD_NEEDS_RESTART" = "1" ]; then
        systemctl daemon-reload
        restart_systemd_and_wait containerd
        CONTAINERD_NEEDS_RESTART=0
    fi

    if [ "$AIRGAP" = "1" ] && [ "$CONTAINERD_DID_MIGRATE_FROM_DOCKER" = "1" ]; then
        logStep "Migrating images from Docker to Containerd..."
        containerd_migrate_images_from_docker
        logSuccess "Images migrated successfully"
    fi

    load_images $src/images

    if systemctl list-unit-files | grep -v disabled | grep -q kubelet.service; then
        systemctl start kubelet
        # If using the internal load balancer the Kubernetes API server will be unavailable until
        # kubelet starts the HAProxy static pod. This check ensures the Kubernetes API server
        # is available before proceeeding.
        # ".." is needed becasue addons can have a CRD names "nodes", like nodes.longhorn.io
        try_5m kubectl --kubeconfig=/etc/kubernetes/kubelet.conf get nodes..
    fi
}

function containerd_configure() {
    if [ "$CONTAINERD_PRESERVE_CONFIG" = "1" ]; then
        echo "Skipping containerd configuration"
        return
    fi
    mkdir -p /etc/containerd
    containerd config default > /etc/containerd/config.toml

    sed -i '/systemd_cgroup/d' /etc/containerd/config.toml
    sed -i '/containerd.runtimes.runc.options/d' /etc/containerd/config.toml
    sed -i 's/level = ""/level = "warn"/' /etc/containerd/config.toml
    cat >> /etc/containerd/config.toml <<EOF
[plugins."io.containerd.grpc.v1.cri".containerd.runtimes.runc.options]
  SystemdCgroup = true
EOF

	if [ -n "$CONTAINERD_TOML_CONFIG" ]; then
        local tmp=$(mktemp)
        echo "$CONTAINERD_TOML_CONFIG" > "$tmp"
        "$DIR/bin/toml" -basefile=/etc/containerd/config.toml -patchfile="$tmp"
    fi

    CONTAINERD_NEEDS_RESTART=1
}

function containerd_configure_ctl() {
    local src="$1"

    if [ -e "/etc/crictl.yaml" ]; then
        return 0
    fi

    cp "$src/crictl.yaml" /etc/crictl.yaml
}

containerd_configure_proxy() {
    local previous_proxy="$(cat /etc/systemd/system/containerd.service.d/http-proxy.conf 2>/dev/null | grep -io 'https*_proxy=[^\" ]*' | awk 'BEGIN { FS="=" }; { print $2 }')"
    local previous_no_proxy="$(cat /etc/systemd/system/containerd.service.d/http-proxy.conf 2>/dev/null | grep -io 'no_proxy=[^\" ]*' | awk 'BEGIN { FS="=" }; { print $2 }')"
    if [ "$PROXY_ADDRESS" = "$previous_proxy" ] && [ "$NO_PROXY_ADDRESSES" = "$previous_no_proxy" ]; then
        return
    fi

    mkdir -p /etc/systemd/system/containerd.service.d
    local file=/etc/systemd/system/containerd.service.d/http-proxy.conf

    echo "# Generated by kURL" > $file
    echo "[Service]" >> $file

    echo "Environment=\"HTTP_PROXY=${PROXY_ADDRESS}\" \"HTTPS_PROXY=${PROXY_ADDRESS}\" \"NO_PROXY=${NO_PROXY_ADDRESSES}\"" >> $file

    CONTAINERD_NEEDS_RESTART=1
}

# Returns 0 on non-xfs filesystems and on xfs filesystems if ftype=1.
containerd_xfs_ftype_enabled() {
    if ! commandExists xfs_info; then
        return 0
    fi

    mkdir -p /var/lib/containerd

    if xfs_info /var/lib/containerd 2>/dev/null | grep -q "ftype=0"; then
        return 1
    fi

    return 0
}

function containerd_migrate_from_docker() {
    if ! commandExists docker; then
        return
    fi

    if ! commandExists kubectl; then
        return
    fi

    echo "Draining node to prepare for migration from docker to containerd"

    # Delete pods that depend on other pods on the same node
    if [ -f "$DIR/addons/ekco/$EKCO_VERSION/reboot/shutdown.sh" ]; then
        bash $DIR/addons/ekco/$EKCO_VERSION/reboot/shutdown.sh
    elif [ -f /opt/ekco/shutdown.sh ]; then
        bash /opt/ekco/shutdown.sh
    else
        logFail "EKCO shutdown script not available. Migration to containerd may fail\n"
        if ! confirmN ; then
            bail "Migration to Containerd has been aborted."
        fi
    fi

    local node=$(hostname | tr '[:upper:]' '[:lower:]')
    kubectl cordon "$node" --kubeconfig=/etc/kubernetes/kubelet.conf

    local allPodUIDs=$(kubectl --kubeconfig=/etc/kubernetes/kubelet.conf get pods --all-namespaces -ojsonpath='{ range .items[*]}{.metadata.name}{"\t"}{.metadata.uid}{"\t"}{.metadata.namespace}{"\n"}{end}' )

    # Drain remaining pods using only the permissions available to kubelet
    while read -r uid; do
        local pod=$(echo "${allPodUIDs[*]}" | grep "$uid")
        if [ -z "$pod" ]; then
            continue
        fi
        local podName=$(echo "$pod" | awk '{ print $1 }')
        local podNamespace=$(echo "$pod" | awk '{ print $3 }')
        # some may timeout but proceed anyway
        kubectl --kubeconfig=/etc/kubernetes/kubelet.conf delete pod "$podName" --namespace="$podNamespace" --timeout=60s || true
    done < <(ls /var/lib/kubelet/pods)

    systemctl stop kubelet

    docker rm -f $(docker ps -a -q) || true # Errors if there are not containers found

    # Reconfigure kubelet to use containerd
    containerdFlags="--container-runtime=remote --container-runtime-endpoint=unix:///run/containerd/containerd.sock"
    sed -i "s@\(KUBELET_KUBEADM_ARGS=\".*\)\"@\1 $containerdFlags\" @" /var/lib/kubelet/kubeadm-flags.env
    systemctl daemon-reload

    CONTAINERD_DID_MIGRATE_FROM_DOCKER=1
}

function containerd_can_migrate_images_from_docker() {
    local images_kb="$(du -sc /var/lib/docker/overlay2 | grep total | awk '{print $1}')"
    local available_kb="$(df --output=avail /var/lib/containerd/ | awk 'NR > 1')"

    if [ -z "$images_kb" ]; then
        logWarn "Unable to determine size of Docker images"
        return 0
    elif [ -z "$available_kb" ]; then
        logWarn "Unable to determine available disk space in /var/lib/containerd/"
        return 0
    else
        local images_kb_x2="$(expr $images_kb + $images_kb)"
        if [ "$available_kb" -lt "$images_kb_x2" ]; then
            local images_human="$(echo "$images_kb" | awk '{print int($1/1024/1024+0.5) "GB"}')"
            local available_human="$(echo "$available_kb" | awk '{print int($1/1024/1024+0.5) "GB"}')"
            logFail "There is not enough available disk space (${available_human}) to migrate images (${images_human}) from Docker to Containerd."
            logFail "Please make sure there is at least 2 x size of Docker images available disk space."
            return 1
        fi
    fi
    return 0
}

function containerd_migrate_images_from_docker() {
    if ! containerd_can_migrate_images_from_docker ; then
        exit 1
    fi

    # we must always clean up $tmpdir since it can take up a lot of space
    local errcode=0
    local tmpdir="$(mktemp -d -p /var/lib/containerd)"
    _containerd_migrate_images_from_docker "$tmpdir" || errcode="$?"
    rm -rf "$tmpdir"
    return "$errcode"
}

function _containerd_migrate_images_from_docker() {
    local tmpdir="$1"
    local imagefile=
    for image in $(docker images --format '{{.Repository}}:{{.Tag}}' | grep -v '^<none>'); do
        imagefile="${tmpdir}/$(echo $image | tr -cd '[:alnum:]').tar"
        (set -x; docker save $image -o "$imagefile")
    done
    for image in $tmpdir/* ; do
        (set -x; ctr -n=k8s.io images import $image)
    done
}
function _yum_install_host_packages() {
    if [ "${SKIP_SYSTEM_PACKAGE_INSTALL}" == "1" ]; then
        logStep "Skipping installation of host packages: ${packages[*]}"
        return
    fi

    local dir="$1"
    local dir_prefix="$2"
    local packages=("${@:3}")

    logStep "Installing host packages ${packages[*]}"
    echo "YUM INSTALLING HOST PACKAGES FROM CONTAINERD ADDON"

    local fullpath=
    fullpath="$(_yum_get_host_packages_path "${dir}" "${dir_prefix}")"
    if ! test -n "$(shopt -s nullglob; echo "${fullpath}"/*.rpm)" ; then
        echo "Will not install host packages ${packages[*]}, no packages found."
        return 0
    fi
    cat > /etc/yum.repos.d/kurl.local.repo <<EOF
[kurl.local]
name=kURL Local Repo
baseurl=file://${fullpath}
enabled=1
gpgcheck=0
repo_gpgcheck=0
EOF
    # We always use the same repo and we are kinda abusing yum here so we have to clear the cache.
    yum clean metadata --disablerepo=* --enablerepo=kurl.local
    yum makecache --disablerepo=* --enablerepo=kurl.local

    # shellcheck disable=SC2086
    if [[ "${packages[*]}" == *"openssl"* && -n $(uname -r | grep "el7") ]]; then
        installed_version=$(yum list available | grep "openssl-libs" | awk '{print $2}' | cut -c 3-)
        # if there is already an openssl-libs package installed, swap with the package version needed for RHEL7
        if [[ -n "${installed_version}" ]]; then
            yum swap openssl-libs-$installed_version openssl-libs-1.0.2k-22.el7_9 -y
        fi
    fi
    # When migrating from Docker to Containerd add-on, Docker is packaged with a higher version of
    # Containerd. We must downgrade Containerd to the version specified as we package the
    # corresponding version of the pause image. If we do not downgrade Containerd, Kubelet will
    # fail to start in airgapped installations with pause image not found.
    if commandExists docker && [ -n "$CONTAINERD_VERSION" ] && [[ "${packages[*]}" == *"containerd.io"* ]]; then
        echo "Downgrade containerd started"
        local next_version=
        local previous_version=
        next_version="$(basename "${fullpath}"/containerd.io*.rpm | grep -o '[0-9][0-9]*\.[0-9][0-9]*\.[0-9][0-9]*')"
        previous_version="$(ctr -v | grep -o '[0-9][0-9]*\.[0-9][0-9]*\.[0-9][0-9]*')"
        logStep "Downgrading containerd, $previous_version -> $next_version"
        if semverCompare "$next_version" "$previous_version" && [ "$SEMVER_COMPARE_RESULT" -lt "0" ]; then
            if uname -r | grep -q "el8" ; then
                yum --disablerepo=* --enablerepo=kurl.local downgrade --allowerasing -y "${packages[@]}"
            else
                yum --disablerepo=* --enablerepo=kurl.local downgrade -y "${packages[@]}"
            fi
        fi
        echo "Downgraded containerd successfully"
        logSuccess "Downgraded containerd"
    fi
    # shellcheck disable=SC2086
    if [[ "${packages[*]}" == *"containerd.io"* && -n $(uname -r | grep "el8") ]]; then
        yum --disablerepo=* --enablerepo=kurl.local install --allowerasing -y "${packages[@]}"
    else
        yum --disablerepo=* --enablerepo=kurl.local install -y "${packages[@]}"
    fi
    yum clean metadata --disablerepo=* --enablerepo=kurl.local
    rm /etc/yum.repos.d/kurl.local.repo

    reset_dnf_module_kurl_local

    logSuccess "Host packages ${packages[*]} installed"
}

